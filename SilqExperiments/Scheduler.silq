// ============================================
// Scheduler.silq - é‡å­ä»»åŠ¡è°ƒåº¦å™¨
// ============================================
// ç»“åˆ QubitPool å’Œ TaskQueue å®ç°ä»»åŠ¡è°ƒåº¦

// å¯¼å…¥æ¨¡å— (Silq ä½¿ç”¨ import è¯­å¥)
// import QubitPool;
// import TaskQueue;

// è°ƒåº¦ç­–ç•¥
enum SchedulingPolicy {
    FIFO,           // å…ˆè¿›å…ˆå‡º
    Priority,       // ä¼˜å…ˆçº§è°ƒåº¦
    ShortestJob,    // æœ€çŸ­ä½œä¸šä¼˜å…ˆ
    QuantumAware    // é‡å­æ„ŸçŸ¥è°ƒåº¦ (è€ƒè™‘ qubit äº²å’Œæ€§)
}

// è°ƒåº¦å™¨é…ç½®
newtype SchedulerConfig = (
    policy: SchedulingPolicy,
    maxQueueSize: !â„•,
    poolSize: !â„•,
    enablePreemption: !ğ”¹,
    timeSlice: !â„•
);

// è°ƒåº¦å™¨çŠ¶æ€
newtype Scheduler = (
    config: SchedulerConfig,
    taskQueue: TaskQueue,
    qubitPool: QubitPool,
    currentTaskId: !â„•,
    scheduledCount: !â„•,
    preemptedCount: !â„•
);

// ============================================
// æ ¸å¿ƒå‡½æ•°
// ============================================

// åˆ›å»ºè°ƒåº¦å™¨
def createScheduler[config: SchedulerConfig](): Scheduler {
    let queueConfig = QueueConfig(
        maxQueueSize: config.maxQueueSize,
        maxConcurrentTasks: 1, // ç®€åŒ–ï¼šå•ä»»åŠ¡æ‰§è¡Œ
        defaultPriority: TaskPriority.Normal
    );
    let poolConfig = PoolConfig(
        poolSize: config.poolSize,
        maxOperationsPerQubit: 1000,
        enableTracking: true
    );
    
    return Scheduler(
        config: config,
        taskQueue: createTaskQueue(queueConfig),
        qubitPool: createQubitPool(config.poolSize, poolConfig),
        currentTaskId: Length([]), // æ— æ•ˆ ID
        scheduledCount: 0,
        preemptedCount: 0
    );
}

// æäº¤ä»»åŠ¡åˆ°è°ƒåº¦å™¨
def submitTask[
    scheduler: Scheduler,
    taskType: TaskType,
    requiredQubits: !â„•,
    parameters: !â„[]
](priority: TaskPriority): (!â„•, Scheduler) {
    var newScheduler = scheduler;
    
    // ç”Ÿæˆ qubit ç´¢å¼• (ç®€åŒ–ï¼šé¡ºåºåˆ†é…)
    var qubitIndices: !â„•[] = [];
    for i in [0..requiredQubits) {
        qubitIndices := qubitIndices ++ [i];
    }
    
    let (taskId, newQueue) := createTask(
        scheduler.taskQueue,
        taskType,
        qubitIndices,
        parameters,
        priority
    );
    
    newScheduler.taskQueue := newQueue;
    
    return (taskId, newScheduler);
}

// è°ƒåº¦å‘¨æœŸ - é€‰æ‹©å¹¶å¯åŠ¨ä¸‹ä¸€ä¸ªä»»åŠ¡
def scheduleTick[scheduler: Scheduler](): Scheduler {
    var newScheduler = scheduler;
    
    // æ£€æŸ¥æ˜¯å¦æœ‰ä»»åŠ¡æ­£åœ¨è¿è¡Œ
    if scheduler.currentTaskId < Length(scheduler.taskQueue.tasks) {
        // ä»»åŠ¡æ­£åœ¨è¿è¡Œï¼Œæ£€æŸ¥æ˜¯å¦å®Œæˆ
        let currentTask = scheduler.taskQueue.tasks[scheduler.currentTaskId];
        if currentTask.status == TaskStatus.Running {
            // æ¨¡æ‹Ÿä»»åŠ¡å®Œæˆ (å®é™…ä¸­éœ€è¦æ£€æŸ¥é‡å­æ“ä½œå®ŒæˆçŠ¶æ€)
            let result := true: !ğ”¹; // ç®€åŒ–ï¼šå‡è®¾æˆåŠŸ
            newScheduler.taskQueue := completeTask(
                scheduler.taskQueue,
                scheduler.currentTaskId,
                result
            );
            newScheduler.currentTaskId := Length([]); // é‡ç½®
            newScheduler.scheduledCount := scheduler.scheduledCount + 1;
        }
    }
    
    // å¦‚æœæ²¡æœ‰ä»»åŠ¡è¿è¡Œï¼Œå¯åŠ¨æ–°ä»»åŠ¡
    if newScheduler.currentTaskId >= Length(newScheduler.taskQueue.tasks) {
        let (pendingIdx, _) := getNextPendingTask(newScheduler.taskQueue);
        if pendingIdx < Length(newScheduler.taskQueue.tasks) {
            newScheduler.taskQueue := startTask(
                newScheduler.taskQueue,
                pendingIdx
            );
            newScheduler.currentTaskId := pendingIdx;
        }
    }
    
    return newScheduler;
}

// æŠ¢å å½“å‰ä»»åŠ¡
def preemptCurrentTask[scheduler: Scheduler](): Scheduler {
    if !scheduler.config.enablePreemption {
        return scheduler;
    }
    
    var newScheduler = scheduler;
    
    if scheduler.currentTaskId < Length(scheduler.taskQueue.tasks) {
        let currentTask = scheduler.taskQueue.tasks[scheduler.currentTaskId];
        if currentTask.status == TaskStatus.Running {
            // æ ‡è®°ä¸ºå¤±è´¥ (ç®€åŒ–å¤„ç†)
            newScheduler.taskQueue := failTask(
                scheduler.taskQueue,
                scheduler.currentTaskId
            );
            newScheduler.currentTaskId := Length([]);
            newScheduler.preemptedCount := scheduler.preemptedCount + 1;
        }
    }
    
    return newScheduler;
}

// è·å–è°ƒåº¦å™¨ç»Ÿè®¡
newtype SchedulerStats = (
    totalSubmitted: !â„•,
    totalScheduled: !â„•,
    totalPreempted: !â„•,
    queueStats: QueueStats,
    poolStats: PoolStats
);

def getSchedulerStats[scheduler: Scheduler](): SchedulerStats {
    return SchedulerStats(
        totalSubmitted: Length(scheduler.taskQueue.tasks),
        totalScheduled: scheduler.scheduledCount,
        totalPreempted: scheduler.preemptedCount,
        queueStats: getQueueStats(scheduler.taskQueue),
        poolStats: getPoolStats(scheduler.qubitPool)
    );
}

// æ‰“å°è°ƒåº¦å™¨çŠ¶æ€
def printSchedulerState[scheduler: Scheduler](): !ğŸ™ {
    let stats := getSchedulerStats(scheduler);
    print("=== Scheduler State ===");
    print($"Submitted: {stats.totalSubmitted}");
    print($"Scheduled: {stats.totalScheduled}");
    print($"Preempted: {stats.totalPreempted}");
    print($"Queue Success Rate: {stats.queueStats.successRate}");
    return ();
}

// ============================================
// è°ƒåº¦ç­–ç•¥å®ç°
// ============================================

// FIFO è°ƒåº¦ - æŒ‰æäº¤é¡ºåºæ‰§è¡Œ
def scheduleFIFO[scheduler: Scheduler](): Scheduler {
    // FIFO å·²åœ¨ scheduleTick ä¸­å®ç°
    return scheduleTick(scheduler);
}

// ä¼˜å…ˆçº§è°ƒåº¦ - é€‰æ‹©æœ€é«˜ä¼˜å…ˆçº§ä»»åŠ¡
def schedulePriority[scheduler: Scheduler](): Scheduler {
    var newScheduler = scheduler;
    
    // æŸ¥æ‰¾æœ€é«˜ä¼˜å…ˆçº§çš„å¾…å¤„ç†ä»»åŠ¡
    var bestIdx := Length(scheduler.taskQueue.tasks);
    var bestPriority := TaskPriority.Low;
    
    for i in [0..Length(scheduler.taskQueue.tasks)) {
        let task = scheduler.taskQueue.tasks[i];
        if task.status == TaskStatus.Pending {
            // ç®€åŒ–ä¼˜å…ˆçº§æ¯”è¾ƒ
            if task.priority == TaskPriority.Critical {
                bestIdx := i;
                bestPriority := TaskPriority.Critical;
                break;
            } else if task.priority == TaskPriority.High && bestPriority < TaskPriority.High {
                bestIdx := i;
                bestPriority := TaskPriority.High;
            } else if task.priority == TaskPriority.Normal && bestPriority < TaskPriority.Normal {
                bestIdx := i;
                bestPriority := TaskPriority.Normal;
            }
        }
    }
    
    if bestIdx < Length(scheduler.taskQueue.tasks) {
        newScheduler.taskQueue := startTask(
            scheduler.taskQueue,
            bestIdx
        );
        newScheduler.currentTaskId := bestIdx;
    }
    
    return newScheduler;
}
