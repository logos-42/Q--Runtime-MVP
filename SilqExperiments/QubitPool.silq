// ============================================
// QubitPool.silq - Qubit èµ„æºæ± æŠ½è±¡
// ============================================
// Silq çš„ç±»å‹ç³»ç»Ÿè‡ªåŠ¨ç®¡ç†é‡å­æ¯”ç‰¹çŠ¶æ€
// æœ¬æ¨¡å—æä¾›ç»å…¸çš„èµ„æºæ± å…ƒæ•°æ®è¿½è¸ª

// Qubit çŠ¶æ€æšä¸¾ (ç»å…¸å…ƒæ•°æ®)
enum QubitState {
    Available,
    Allocated,
    Measured,
    Error
}

// Qubit ä¿¡æ¯è®°å½•
newtype QubitInfo = (
    id: !â„•,
    state: QubitState,
    allocationTime: !â„•,
    operationCount: !â„•
);

// èµ„æºæ± é…ç½®
newtype PoolConfig = (
    poolSize: !â„•,
    maxOperationsPerQubit: !â„•,
    enableTracking: !ğ”¹
);

// èµ„æºæ± çŠ¶æ€
newtype QubitPool = (
    qubits: QubitInfo[],
    config: PoolConfig,
    allocatedCount: !â„•,
    totalOperations: !â„•
);

// ============================================
// æ ¸å¿ƒå‡½æ•°
// ============================================

// åˆ›å»ºæ–°çš„ Qubit èµ„æºæ± 
def createQubitPool[size: !â„•](config: PoolConfig): QubitPool {
    var qubits: QubitInfo[] = [];
    for i in [0..size) {
        let info = QubitInfo(
            id: i,
            state: QubitState.Available,
            allocationTime: 0,
            operationCount: 0
        );
        qubits := qubits ++ [info];
    }
    return QubitPool(
        qubits: qubits,
        config: config,
        allocatedCount: 0,
        totalOperations: 0
    );
}

// åˆ†é… Qubit (è¿”å›ç»å…¸ç´¢å¼•ï¼Œå®é™…é‡å­æ¯”ç‰¹ç”± Silq ç®¡ç†)
def allocateQubit[pool: QubitPool](): (!â„•, QubitPool) {
    var newPool = pool;
    for i in [0..Length(pool.qubits)) {
        if pool.qubits[i].state == QubitState.Available {
            // æ›´æ–° Qubit çŠ¶æ€
            let oldInfo = pool.qubits[i];
            let newInfo = QubitInfo(
                id: oldInfo.id,
                state: QubitState.Allocated,
                allocationTime: oldInfo.allocationTime + 1,
                operationCount: 0
            );
            newPool.qubits[i] := newInfo;
            newPool.allocatedCount := newPool.allocatedCount + 1;
            return (i, newPool);
        }
    }
    // èµ„æºæ± è€—å°½
    return (Length(pool.qubits), newPool); // è¿”å›è¶Šç•Œç´¢å¼•è¡¨ç¤ºå¤±è´¥
}

// é‡Šæ”¾ Qubit
def releaseQubit[pool: QubitPool](qubitId: !â„•): QubitPool {
    var newPool = pool;
    if qubitId < Length(pool.qubits) {
        let oldInfo = pool.qubits[qubitId];
        let newInfo = QubitInfo(
            id: oldInfo.id,
            state: QubitState.Available,
            allocationTime: 0,
            operationCount: oldInfo.operationCount
        );
        newPool.qubits[qubitId] := newInfo;
        newPool.allocatedCount := newPool.allocatedCount - 1;
    }
    return newPool;
}

// è®°å½• Qubit æ“ä½œ
def recordOperation[pool: QubitPool](qubitId: !â„•): QubitPool {
    var newPool = pool;
    if qubitId < Length(pool.qubits) {
        let oldInfo = pool.qubits[qubitId];
        let newInfo = QubitInfo(
            id: oldInfo.id,
            state: oldInfo.state,
            allocationTime: oldInfo.allocationTime,
            operationCount: oldInfo.operationCount + 1
        );
        newPool.qubits[qubitId] := newInfo;
        newPool.totalOperations := newPool.totalOperations + 1;
    }
    return newPool;
}

// è·å–å¯ç”¨ Qubit æ•°é‡
def getAvailableCount[pool: QubitPool](): !â„• {
    var count := 0: !â„•;
    for i in [0..Length(pool.qubits)) {
        if pool.qubits[i].state == QubitState.Available {
            count := count + 1;
        }
    }
    return count;
}

// è·å–èµ„æºæ± ç»Ÿè®¡ä¿¡æ¯
newtype PoolStats = (
    totalQubits: !â„•,
    availableQubits: !â„•,
    allocatedQubits: !â„•,
    totalOperations: !â„•,
    avgOperationsPerQubit: !â„•
);

def getPoolStats[pool: QubitPool](): PoolStats {
    let available := getAvailableCount(pool);
    let allocated := pool.allocatedCount;
    let total := Length(pool.qubits);
    let avgOps := if total > 0 then pool.totalOperations / total else 0;
    
    return PoolStats(
        totalQubits: total,
        availableQubits: available,
        allocatedQubits: allocated,
        totalOperations: pool.totalOperations,
        avgOperationsPerQubit: avgOps
    );
}

// æ‰“å°èµ„æºæ± çŠ¶æ€ (è°ƒè¯•ç”¨)
def printPoolState[pool: QubitPool](): !ğŸ™ {
    let stats := getPoolStats(pool);
    print("=== Qubit Pool State ===");
    print($"Total: {stats.totalQubits}");
    print($"Available: {stats.availableQubits}");
    print($"Allocated: {stats.allocatedQubits}");
    print($"Total Operations: {stats.totalOperations}");
    return ();
}
