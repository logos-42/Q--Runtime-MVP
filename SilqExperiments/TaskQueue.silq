// ============================================
// TaskQueue.silq - é‡å­ä»»åŠ¡é˜Ÿåˆ—
// ============================================
// å®ç°ç»å…¸ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†ï¼Œç”¨äºè¿½è¸ªé‡å­æ“ä½œè¯·æ±‚

// ä»»åŠ¡çŠ¶æ€
enum TaskStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled
}

// ä»»åŠ¡ç±»å‹
enum TaskType {
    GateOperation,
    Measurement,
    CircuitExecution,
    StatePreparation
}

// ä»»åŠ¡ä¼˜å…ˆçº§
enum TaskPriority {
    Low,
    Normal,
    High,
    Critical
}

// ä»»åŠ¡å®šä¹‰
newtype QuantumTask = (
    id: !â„•,
    taskType: TaskType,
    priority: TaskPriority,
    status: TaskStatus,
    qubitIndices: !â„•[],
    parameters: !â„[],
    createdAt: !â„•,
    startedAt: !â„•,
    completedAt: !â„•,
    result: !ğ”¹
);

// é˜Ÿåˆ—é…ç½®
newtype QueueConfig = (
    maxQueueSize: !â„•,
    maxConcurrentTasks: !â„•,
    defaultPriority: TaskPriority
);

// ä»»åŠ¡é˜Ÿåˆ—çŠ¶æ€
newtype TaskQueue = (
    tasks: QuantumTask[],
    config: QueueConfig,
    nextTaskId: !â„•,
    runningCount: !â„•,
    completedCount: !â„•,
    failedCount: !â„•
);

// ============================================
// æ ¸å¿ƒå‡½æ•°
// ============================================

// åˆ›å»ºæ–°çš„ä»»åŠ¡é˜Ÿåˆ—
def createTaskQueue[config: QueueConfig](): TaskQueue {
    return TaskQueue(
        tasks: [],
        config: config,
        nextTaskId: 0,
        runningCount: 0,
        completedCount: 0,
        failedCount: 0
    );
}

// åˆ›å»ºæ–°ä»»åŠ¡
def createTask[
    queue: TaskQueue,
    taskType: TaskType,
    qubitIndices: !â„•[],
    parameters: !â„[]
](priority: TaskPriority): (!â„•, TaskQueue) {
    var newQueue = queue;
    
    // æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦å·²æ»¡
    if Length(queue.tasks) >= config.maxQueueSize {
        return (Length(queue.tasks), queue); // è¿”å›é”™è¯¯
    }
    
    let task = QuantumTask(
        id: queue.nextTaskId,
        taskType: taskType,
        priority: priority,
        status: TaskStatus.Pending,
        qubitIndices: qubitIndices,
        parameters: parameters,
        createdAt: queue.nextTaskId, // ç®€åŒ–ï¼šä½¿ç”¨ ID ä½œä¸ºæ—¶é—´æˆ³
        startedAt: 0,
        completedAt: 0,
        result: false
    );
    
    newQueue.tasks := queue.tasks ++ [task];
    newQueue.nextTaskId := queue.nextTaskId + 1;
    
    return (task.id, newQueue);
}

// ä»é˜Ÿåˆ—ä¸­è·å–ä¸‹ä¸€ä¸ªå¾…å¤„ç†ä»»åŠ¡
def getNextPendingTask[queue: TaskQueue](): (!â„•, !ğŸ™) {
    for i in [0..Length(queue.tasks)) {
        if queue.tasks[i].status == TaskStatus.Pending {
            return (i, ());
        }
    }
    return (Length(queue.tasks), ()); // æœªæ‰¾åˆ°
}

// å¼€å§‹æ‰§è¡Œä»»åŠ¡
def startTask[queue: TaskQueue](taskId: !â„•): TaskQueue {
    var newQueue = queue;
    
    // æ£€æŸ¥å¹¶å‘é™åˆ¶
    if queue.runningCount >= queue.config.maxConcurrentTasks {
        return queue;
    }
    
    for i in [0..Length(queue.tasks)) {
        if queue.tasks[i].id == taskId && queue.tasks[i].status == TaskStatus.Pending {
            let oldTask = queue.tasks[i];
            let newTask = QuantumTask(
                id: oldTask.id,
                taskType: oldTask.taskType,
                priority: oldTask.priority,
                status: TaskStatus.Running,
                qubitIndices: oldTask.qubitIndices,
                parameters: oldTask.parameters,
                createdAt: oldTask.createdAt,
                startedAt: oldTask.createdAt + 1,
                completedAt: 0,
                result: oldTask.result
            );
            newQueue.tasks[i] := newTask;
            newQueue.runningCount := queue.runningCount + 1;
            break;
        }
    }
    
    return newQueue;
}

// å®Œæˆä»»åŠ¡
def completeTask[queue: TaskQueue](taskId: !â„•, result: !ğ”¹): TaskQueue {
    var newQueue = queue;
    
    for i in [0..Length(queue.tasks)) {
        if queue.tasks[i].id == taskId && queue.tasks[i].status == TaskStatus.Running {
            let oldTask = queue.tasks[i];
            let newTask = QuantumTask(
                id: oldTask.id,
                taskType: oldTask.taskType,
                priority: oldTask.priority,
                status: TaskStatus.Completed,
                qubitIndices: oldTask.qubitIndices,
                parameters: oldTask.parameters,
                createdAt: oldTask.createdAt,
                startedAt: oldTask.startedAt,
                completedAt: oldTask.startedAt + 1,
                result: result
            );
            newQueue.tasks[i] := newTask;
            newQueue.runningCount := queue.runningCount - 1;
            newQueue.completedCount := queue.completedCount + 1;
            break;
        }
    }
    
    return newQueue;
}

// å¤±è´¥ä»»åŠ¡
def failTask[queue: TaskQueue](taskId: !â„•): TaskQueue {
    var newQueue = queue;
    
    for i in [0..Length(queue.tasks)) {
        if queue.tasks[i].id == taskId && queue.tasks[i].status == TaskStatus.Running {
            let oldTask = queue.tasks[i];
            let newTask = QuantumTask(
                id: oldTask.id,
                taskType: oldTask.taskType,
                priority: oldTask.priority,
                status: TaskStatus.Failed,
                qubitIndices: oldTask.qubitIndices,
                parameters: oldTask.parameters,
                createdAt: oldTask.createdAt,
                startedAt: oldTask.startedAt,
                completedAt: oldTask.startedAt + 1,
                result: false
            );
            newQueue.tasks[i] := newTask;
            newQueue.runningCount := queue.runningCount - 1;
            newQueue.failedCount := queue.failedCount + 1;
            break;
        }
    }
    
    return newQueue;
}

// è·å–é˜Ÿåˆ—ç»Ÿè®¡
newtype QueueStats = (
    totalTasks: !â„•,
    pendingTasks: !â„•,
    runningTasks: !â„•,
    completedTasks: !â„•,
    failedTasks: !â„•,
    successRate: !â„
);

def getQueueStats[queue: TaskQueue](): QueueStats {
    var pending := 0: !â„•;
    var running := 0: !â„•;
    var completed := 0: !â„•;
    var failed := 0: !â„•;
    
    for i in [0..Length(queue.tasks)) {
        let task = queue.tasks[i];
        if task.status == TaskStatus.Pending { pending := pending + 1; }
        else if task.status == TaskStatus.Running { running := running + 1; }
        else if task.status == TaskStatus.Completed { completed := completed + 1; }
        else if task.status == TaskStatus.Failed { failed := failed + 1; }
    }
    
    let total := completed + failed;
    let rate := if total > 0 then (!â„)(completed) / (!â„)(total) else 0.0;
    
    return QueueStats(
        totalTasks: Length(queue.tasks),
        pendingTasks: pending,
        runningTasks: running,
        completedTasks: completed,
        failedTasks: failed,
        successRate: rate
    );
}

// æŒ‰ä¼˜å…ˆçº§æ’åºä»»åŠ¡ (ç®€å•å®ç°)
def sortByPriority[queue: TaskQueue](): TaskQueue {
    // Silq ç›®å‰ä¸æ”¯æŒå¤æ‚çš„æ’åºï¼Œè¿™é‡Œè¿”å›åŸé˜Ÿåˆ—
    // å®é™…å®ç°éœ€è¦è‡ªå®šä¹‰æ’åºé€»è¾‘
    return queue;
}
